# 脆弱性パターン例

## 概要

言語・フレームワーク別に実際に発生しやすい脆弱性パターンを示す。コードレビュー時に重点的にチェックすべき箇所の参考とする。

## Python / FastAPI

### 1. Pydanticバリデーションの迂回

```python
# 脆弱: dictで受け取るとバリデーションが効かない
@router.post("/users")
def create_user(data: dict):
    repository.create(**data)  # 任意のフィールドを送信可能

# 安全: Pydanticモデルで型安全にバリデーション
class CreateUserRequest(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    email: str = Field(..., pattern=r'^[\w.+-]+@[\w-]+\.[\w.]+$')

@router.post("/users")
def create_user(data: CreateUserRequest):
    repository.create(name=data.name, email=data.email)
```

### 2. pickleデシリアライゼーション

```python
# 脆弱: ユーザー入力をpickleでデシリアライズ
import pickle
import base64

@router.post("/import")
def import_data(encoded_data: str):
    data = pickle.loads(base64.b64decode(encoded_data))  # 任意コード実行
    return {"imported": len(data)}

# 安全: JSONで受け取り、型安全にパース
@router.post("/import")
def import_data(data: list[ImportItem]):
    repository.bulk_create(data)
    return {"imported": len(data)}
```

### 3. 安全でないリダイレクト

```python
# 脆弱: オープンリダイレクト
@router.get("/redirect")
def redirect(url: str = Query(...)):
    return RedirectResponse(url=url)  # 任意のURLにリダイレクト

# 安全: ホワイトリストによるバリデーション
from urllib.parse import urlparse

ALLOWED_REDIRECT_HOSTS = {"app.example.com", "www.example.com"}

@router.get("/redirect")
def redirect(url: str = Query(...)):
    parsed = urlparse(url)
    if parsed.hostname not in ALLOWED_REDIRECT_HOSTS:
        raise HTTPException(status_code=400, detail="Invalid redirect URL")
    return RedirectResponse(url=url)
```

## JavaScript / Node.js

### 1. プロトタイプ汚染

```javascript
// 脆弱: オブジェクトのマージにユーザー入力を直接使用
function merge(target, source) {
    for (const key in source) {
        target[key] = source[key];  // __proto__の操作が可能
    }
    return target;
}

// 攻撃例: {"__proto__": {"isAdmin": true}}
app.post('/settings', (req, res) => {
    const settings = merge({}, req.body);  // プロトタイプ汚染
});

// 安全: キーのバリデーション
function safeMerge(target, source, allowedKeys) {
    for (const key of allowedKeys) {
        if (key in source) {
            target[key] = source[key];
        }
    }
    return target;
}
```

### 2. eval / Function コンストラクタ

```javascript
// 脆弱: ユーザー入力をevalで実行
app.post('/calculate', (req, res) => {
    const result = eval(req.body.expression);  // 任意コード実行
    res.json({ result });
});

// 安全: パーサーライブラリを使用
import { evaluate } from 'mathjs';

app.post('/calculate', (req, res) => {
    try {
        const result = evaluate(req.body.expression);
        res.json({ result });
    } catch (e) {
        res.status(400).json({ error: 'Invalid expression' });
    }
});
```

### 3. パストラバーサル（Express）

```javascript
// 脆弱: ユーザー入力をファイルパスに使用
app.get('/files/:filename', (req, res) => {
    const filePath = path.join('/uploads', req.params.filename);
    res.sendFile(filePath);  // ../../../etc/passwd にアクセス可能
});

// 安全: パス解決後の検証
app.get('/files/:filename', (req, res) => {
    const uploadsDir = path.resolve('/uploads');
    const filePath = path.resolve(uploadsDir, req.params.filename);

    if (!filePath.startsWith(uploadsDir)) {
        return res.status(400).json({ error: 'Invalid path' });
    }

    if (!fs.existsSync(filePath)) {
        return res.status(404).json({ error: 'File not found' });
    }

    res.sendFile(filePath);
});
```

## フレームワーク共通

### 1. Mass Assignment

```python
# 脆弱: リクエストボディをそのままモデルに適用
@router.put("/users/{user_id}")
def update_user(user_id: str, data: dict):
    user = repository.find(user_id)
    for key, value in data.items():
        setattr(user, key, value)  # role, is_adminも変更可能
    repository.save(user)

# 安全: 更新可能なフィールドを明示的に定義
class UpdateUserRequest(BaseModel):
    name: str | None = None
    email: str | None = None
    # role, is_admin は含めない

@router.put("/users/{user_id}")
def update_user(
    user_id: str,
    data: UpdateUserRequest,
    current_user: User = Depends(get_current_user),
):
    if current_user.id != user_id:
        raise HTTPException(status_code=403)
    update_data = data.model_dump(exclude_unset=True)
    repository.update(user_id, **update_data)
```

### 2. レースコンディション

```python
# 脆弱: チェックと操作が分離（TOCTOU）
@router.post("/transfer")
async def transfer(from_id: str, to_id: str, amount: float):
    sender = repository.find(from_id)
    if sender.balance < amount:
        raise HTTPException(status_code=400, detail="Insufficient funds")
    # 並行リクエストで二重引き落としの可能性
    sender.balance -= amount
    receiver = repository.find(to_id)
    receiver.balance += amount
    repository.save(sender)
    repository.save(receiver)

# 安全: トランザクションとロックを使用
@router.post("/transfer")
async def transfer(from_id: str, to_id: str, amount: float):
    async with database.transaction():
        # SELECT FOR UPDATE でロック
        sender = await repository.find_for_update(from_id)
        if sender.balance < amount:
            raise HTTPException(status_code=400, detail="Insufficient funds")
        receiver = await repository.find_for_update(to_id)
        sender.balance -= amount
        receiver.balance += amount
        await repository.save(sender)
        await repository.save(receiver)
```

### 3. タイミング攻撃

```python
# 脆弱: 文字列比較が短絡評価される
def verify_api_key(provided_key: str, stored_key: str) -> bool:
    return provided_key == stored_key  # タイミングサイドチャネル

# 安全: 定数時間比較
import hmac

def verify_api_key(provided_key: str, stored_key: str) -> bool:
    return hmac.compare_digest(
        provided_key.encode(),
        stored_key.encode(),
    )
```

### 4. SSRF（Server-Side Request Forgery）

```python
# 脆弱: ユーザー指定のURLにリクエスト
@router.post("/fetch")
async def fetch_url(url: str):
    response = httpx.get(url)  # 内部ネットワークにアクセス可能
    return {"content": response.text}

# 安全: URL検証とホワイトリスト
import ipaddress
from urllib.parse import urlparse

BLOCKED_NETWORKS = [
    ipaddress.ip_network("10.0.0.0/8"),
    ipaddress.ip_network("172.16.0.0/12"),
    ipaddress.ip_network("192.168.0.0/16"),
    ipaddress.ip_network("169.254.169.254/32"),  # クラウドメタデータ
    ipaddress.ip_network("127.0.0.0/8"),
]

def validate_url(url: str) -> bool:
    parsed = urlparse(url)
    if parsed.scheme not in ("http", "https"):
        return False
    try:
        import socket
        ip = socket.gethostbyname(parsed.hostname)
        addr = ipaddress.ip_address(ip)
        return not any(addr in net for net in BLOCKED_NETWORKS)
    except (socket.gaierror, ValueError):
        return False

@router.post("/fetch")
async def fetch_url(url: str):
    if not validate_url(url):
        raise HTTPException(status_code=400, detail="Invalid URL")
    response = httpx.get(url, follow_redirects=False, timeout=5.0)
    return {"content": response.text[:10000]}  # レスポンスサイズも制限
```

### 5. ログインジェクション

```python
# 脆弱: ユーザー入力をそのままログに出力
logger.info(f"User logged in: {username}")
# 攻撃例: username="admin\n2025-01-30 INFO User admin granted admin access"

# 安全: 構造化ログを使用
logger.info("user_login", extra={"username": username.replace("\n", "\\n")})

# Better: structlogを使用
import structlog
logger = structlog.get_logger()
logger.info("user_login", username=username)  # 自動的にエスケープされる
```

## 設計レベルの脆弱性

### 1. 不適切な認証フロー

```
# 脆弱な設計
1. ユーザーがパスワードリセットを要求
2. サーバーがメールで新しいパスワードを平文で送信  ← 危険
3. ユーザーが新しいパスワードでログイン

# 安全な設計
1. ユーザーがパスワードリセットを要求
2. サーバーが時間制限付きトークンを生成（有効期限: 1時間）
3. トークン付きURLをメールで送信
4. ユーザーがトークンを使用して新しいパスワードを設定
5. 使用済みトークンを無効化
```

### 2. 情報の過剰露出

```
# 脆弱な設計
API: GET /api/v1/users → すべてのユーザー情報を返却（管理者用データ含む）
フロントエンド: JavaScript側でフィルタリング

# 安全な設計
API: GET /api/v1/users → ロールに応じたフィールドのみ返却
    - 一般ユーザー: {id, name, avatar}
    - 管理者: {id, name, email, role, created_at, last_login}
```

## まとめ

コードレビュー時に特に注意すべきパターン:

1. **文字列連結/フォーマットによるクエリ構築**: ORM/パラメータ化クエリを使用
2. **ユーザー入力のデシリアライゼーション**: 安全な形式（JSON）を使用
3. **dictやkwargsでの柔軟すぎるデータ受け渡し**: 型安全なスキーマを使用
4. **チェックと操作の分離**: トランザクションとロックを使用
5. **外部URLへのリクエスト**: URLバリデーションとネットワーク制限
6. **ファイルパスの構築**: パス解決後のディレクトリ検証
